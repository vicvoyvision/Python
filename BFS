


from collections import deque 
class Solution:
    def wallsAndGates(self, rooms):
        """
        Do not return anything, modify rooms in-place instead.
        """
        dic=self.returndic(rooms)
        
        for i in range(len(rooms)):
            for j in range(len(rooms[0])):
                if rooms[i][j]==2147483647:
                    
                    rooms[i][j]=self.search(i,j,dic,rooms)
                
        return rooms
        
    def returndic(self,rooms):
        dic={}
        for i in range(len(rooms)):
            for j in range(len(rooms[0])):
                if rooms[i][j]==2147483647:
                    
                    dic[(i,j)]=self.around(i,j,rooms)
            
        return dic
        
    def around(self,i,j,rooms):
        val=[]
        # have left
        if j >0 and rooms[i][j-1]!= -1:
            val.append((i,j-1))
        #have right
        if j<len(rooms[0])-1 and rooms[i][j+1]!= -1:
            val.append((i,j+1))
        #have up
        if i>0 and rooms[i-1][j]!= -1:
            val.append((i-1,j))
        #have down
        if i<len(rooms)-1 and rooms[i+1][j]!= -1:
            val.append((i+1,j))
        
        return val
    
    def search(self,i,j,dic,rooms):
        m=20000
        search_queue = deque()  # 建立一个双端队列
        
        #dic=self.returndic(rooms)
        d={}
        search_queue.append((i,j)) # 将你的邻居都加入到这个搜索队列中
        seen=set()#这个数组用于记录检查过的
        d[(i,j)]=0
        while (len(search_queue)>0):#队列不为空时循环执行
            
            
            vertex=search_queue.popleft()#对队列中的第一项进行判断，出队
            nodes=dic[vertex]
            for w in nodes:
                d[w]=d[vertex]+1
                if w not in seen:
                    if rooms[w[0]][w[1]]==0:
                        
                        m=min(d[w],m)
                        
                        break
                    
                    search_queue.append(w)
                    seen.add(w)
                    
        if m!=20000:
            return m
        else:
            return 2147483647
                    

                    
        
s=Solution()
rooms=[[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]


a=s.around(0,0,rooms)
dic=s.returndic(rooms)
